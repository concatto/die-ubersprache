#Options
GenerateScanner = true
GenerateParser = true
Language = Java
ScannerName = Lexico
ParserName = Sintatico
SemanticName = Semantico
Package = grammar
ScannerCaseSensitive = true
ScannerTable = Full
Input = String
Parser = SLR
#RegularDefinitions
NUM: [0-9]
ID: [a-zA-Z_][a-zA-Z0-9_]*
HEX: 0x[0-9A-F]+
BIN: 0b[0-1]+
STR: \"[^\"]*\"
COMMENT: / /.*
M_COMMENT: /\*([^\*]|\*+[^\*/])*\*+/
#Tokens
INT_LIT : {NUM}+
FLOAT_LIT: {NUM}*\.{NUM}+
BIN_LIT : {BIN}
HEX_LIT : {HEX}
STRING_LIT : {STR}

RB_OPEN : "("
RB_CLOSE : ")"
SB_OPEN : "["
SB_CLOSE : "]"
CB_OPEN : "{"
CB_CLOSE : "}"
INCREMENT: "++"
DECREMENT: "--"
PLUS : "+"
MINUS : "-"
DIV : "/"
MULT : "*"
COMMA : ","
MOD: "%" 
COLON : ":"
END : ";"
GT : "grösser als"
LT : "kleiner als"
GTE : "grösser oder gleich"
LTE : "kleiner oder gleich"
EQ : "gleich"
NEQ : "ungleich"
ASSIGN : "erhält"
M_COMMENT : {M_COMMENT}
COMMENT : {COMMENT}
SHIFT_RIGHT: ">>"
SHIFT_LEFT: "<<"
BIT_AND: "&"
BIT_OR: "|"
BIT_NOT: "~"
BIT_XOR: "^"
AND : "und"
OR : "oder"
NOT : "nicht"
VOID : "leer" //void
INT : "ganze" //integer
FLOAT : "reelle" //decimal
STRING : "zeichenkette" //string
BOOL : "boolesche" //boolean
CHAR: "zeichen" //char
FUNC : "funktion" //function
RETURN : "zurückliefern" //return
GIVES : "liefert" //gives
BACK : "zurück" //back, as in: gives int back; liefert ganze zurück
IF : "falls" //if
ELSE : "sonst" //else
FALSE : "falsch" //false
TRUE: "wahr" //true
WHILE : "während" //while
FOR : "für" //for
DO : "tun" //do
READ: "lesen"
WRITE: "schreiben"

ID : {ID}

: [\s\t\n\r]
#NonTerminals
<function>
<loop_open_close>
<statement_r>
<statement>
<decl_assign>
<assignment>
<declaration>
<id_r>
<input>
<output>
<condition>

<exp>
<exp1>
<exp2>
<exp3>
<exp4>
<exp5>
<exp6>
<exp7>
<exp8>
<exp9>
<exp10>
<literal>
<relational>
<negation>
<bitwise>
<arith_low>
<arith_high>
<type>
<parameters>

#Grammar
<function>		::= FUNC ID RB_OPEN RB_CLOSE GIVES <type> BACK CB_OPEN <statement_r> CB_CLOSE;
<loop_open_close>	::= CB_OPEN <statement> CB_CLOSE | RB_OPEN <exp> RB_CLOSE;
<statement_r>	::= <statement_r> <statement> END | <statement> END;
<statement>	::= <decl_assign> | <assignment> | <declaration> | <input> | <output>;
<decl_assign>	::= <type> <assignment>;
<assignment>	::= ID ASSIGN <exp>;
<declaration>	::= <type> <id_r>;
<id_r>		::= ID COMMA <id_r> | ID;	
<input>		::= READ ID;
<output>		::= WRITE <exp>;

<condition>	::= IF <loop_open_close> | WHILE <loop_open_close>;

<exp> 		::= <exp> OR <exp1> | <exp1>;
<exp1>		::= <exp1> AND <exp2> | <exp2>;
<exp2>		::= <exp2> BIT_OR <exp3> | <exp3>;
<exp3>		::= <exp3> BIT_XOR <exp4> | <exp4>;
<exp4>		::= <exp4> BIT_AND <exp5> | <exp5>;
<exp5>		::= <exp5> <relational> <exp6> | <exp6>;
<exp6>		::= <exp6> <bitwise> <exp7> | <exp7>;
<exp7>		::= <exp7> <arith_low> <exp8> | <exp8>;
<exp8>		::= <exp8> <arith_high> <exp9> | <exp9> ;
<exp9> 		::= <negation> <exp10> | <exp10>;
<exp10>		::= <literal> | ID | RB_OPEN  <exp> RB_CLOSE ;

<literal>		::= INT_LIT | FLOAT_LIT | BIN_LIT | HEX_LIT | STRING_LIT;	
<relational>	::= GT | LT | GTE | LTE | EQ | NEQ; 
<negation>	::= MINUS | BIT_NOT | NOT;
<bitwise>		::= SHIFT_LEFT | SHIFT_RIGHT;
<arith_low> 	::= PLUS | MINUS;
<arith_high>	::= MULT | DIV | MOD;
<type>		::= INT | FLOAT | STRING | BOOL | VOID | CHAR;
<parameters> 	::= ID | ID <parameters> ;
